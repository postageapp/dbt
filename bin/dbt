#!/usr/bin/env node

// == Imports ===============================================================

var path = require('path');
var fs = require('fs');

var dbt = require('../lib/dbt');

// == Constants =============================================================

var configNames = [
  'config/database.json',
  'config/database.yml',
  'config/database.yaml',
  'config/config.json'
];

var envNames = [
  'NODE_ENV',
  'RACK_ENV',
  'RAILS_ENV'
];

// == Support Methods =======================================================

function changeDatabaseName(options) {
  var transform = stream.Transform();

  return ;
}

function relativePath(fullPath) {
  if (!fullPath) {
    return fullPath;
  }

  var cwd = process.cwd();

  if (fullPath.substr(0, cwd.length) === cwd) {
    return fullPath.substr(cwd.length + 1, fullPath.length);
  }

  return fullPath;
}

function defaultEnv() {
  var env;

  envNames.forEach(function(name) {
    if (process.env[name] && !env) {
      env = process.env[name];
    }
  })

  return env || 'development';
}

function findConfig() {
  var dir;
  var pdir;
  var foundConfigPath;

  for (var dir = process.cwd(); dir != pdir; dir = path.resolve(dir, '..')) {
    configNames.forEach(function(configName) {
      var configPath = path.resolve(dir, configName);

      if (fs.existsSync(configPath)) {
        foundConfigPath = configPath;
      }
    })

    if (foundConfigPath) {
      return foundConfigPath;
    }

    pdir = dir;
  }
}

function readConfigYAML(configPath, env) {
  var YAML = require('yaml-js');

  var data = YAML.load(fs.readFileSync(configPath));

  return data && data[env];
}

function readConfigJSON(configPath, env) {
  var data = JSON.parse(fs.readFileSync(configPath));

  return data && data[env];
}

function readConfig(configPath, env) {
  switch (path.extname(configPath)) {
    case '.yaml':
    case '.yml':
      return readConfigYAML(configPath, env);
      break;
    case '.json':
      return readConfigJSON(configPath, env);
      break;
  }
}

function mostRecentSnapshotPath(dir) {
  var mostRecent;
  var highestTimestamp = 0;

  fs.readdirSync(dir).forEach(function(file) {
    var timestamp = parseInt(file.split('.')[1]);

    if (timestamp > highestTimestamp) {
      mostRecent = path.resolve(dir, file);
      highestTimestamp = timestamp;
    }
  })

  return mostRecent;
}

function currentSnapshotPath(dir, dbName) {
  return path.resolve(dir, dbName + '.' + Math.floor(new Date().getTime() / 1000) + '.dump');
}

function currentStructurePath(dir, dbName) {
  return path.resolve(dir, dbName + '.' + Math.floor(new Date().getTime() / 1000) + '.sql');
}

// == Main ==================================================================

var configPathDefault = findConfig();
var snapshotDirDefault = configPathDefault && path.resolve(configPathDefault, '../..', 'db/snapshots');

var options = require('commander').
  option('-s --snapshot', 'Snapshot the current database structure and data').
  option('-u --structure', 'Snapshot the current database structure').
  option('-r --restore', 'Restore the current database').
  option('-d --database [database]', 'Database to snapshot from or restore to').
  option('-e --env [env]', 'Use a specific environment', defaultEnv()).
  option('-c --config [config]', 'Configuration file path', configPathDefault).
  option('-p --dir [dir]', 'Snapshot directory path to save to or read from', snapshotDirDefault).
  option('-f --file [file]', 'Filename to read from or save to').
  option('-i --info', 'Show the current configuration and exit').
  option('-l --log', 'Log which commands are executed').
  option('-a --adapter [adapter]', 'Use database adapter (postgresql|mysql)').
  option('-t --test', 'Test the current configuration').
  version(require('../package.json').version).
  parse(process.argv);

if (options.args) {
  options.file = options.args[0];
}

var snapshotDir = options.dir;

if (!fs.existsSync(options.config)) {
  console.error("Could not find a configuration file to read.");

  process.exit(-12);
}

var config = readConfig(options.config, options.env);

if (!config) {
  console.error("Could not find configuration for environment '" + options.env + "' in config file '" + options.config + "'");

  process.exit(-12);
}

options.username = options.username || config.username;
options.password = options.password || config.password;
options.host = options.host || config.host;
options.database = options.database || config.database;
options.adapter = options.adapter || config.adapter || config.dialect || config.protocol;

switch (options.adapter) {
  case 'postgis':
  case 'postgres':
    options.adapter = 'postgresql';
    break;
  case 'mysql2':
    options.adapter = 'mysql';
    break;
}

// FIX: Whitelist adapter.
var handler = options.adapter && require('../lib/dbt/' + options.adapter + '/handler');

if (!options.database) {
  console.error("Could not determine which database to use");
  process.exit(-11);
}

if (options.info) {
  console.log('Detected Configuration')
  console.log('------------------------------------------------')
  console.log('    Adapter: ' + options.adapter);
  console.log('Config Path: ' + relativePath(options.config));
  console.log('        Env: ' + options.env);

  if (options.host) {
    console.log('       Host: ' + options.host);
  }

  if (options.port) {
    console.log('       Port: ' + options.port);
  }

  if (options.socket) {
    console.log('     Socket: ' + options.socket);
  }

  if (options.username) {
    console.log('   Username: ' + options.username);
  }

  if (options.password) {
    console.log('   Password: ' + options.password);
  }

  console.log('   Database: ' + options.database);
  console.log('  Snapshots: ' + relativePath(options.dir));

  process.exit(0);
}

if (options.test) {
  handler.test(options, function(err, code) {
    switch (err && err.code) {
      case 'ENOENT':
        console.error('The shell command was not found');
        break;
      default:
        console.log(code);
    }
  });
}
else if (options.snapshot) {
  var snapshotFile = options.file || currentSnapshotPath(snapshotDir, options.database);

  handler.snapshotCreate(snapshotFile, options);
}
else if (options.structure) {
  var structureFile = options.file || currentStructurePath(snapshotDir, options.database);

  handler.structureCreate(structureFile, options);
}
else if (options.restore) {
  var snapshotFile = options.file || mostRecentSnapshotPath(snapshotDir)

  handler.restore(snapshotFile);
}
else {
  handler.shell(options);
}
